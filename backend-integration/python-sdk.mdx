---
title: "Python SDK"
description: "Documentation for the ParityDeals Python SDK"
icon: 'python'
---

## Overview

The ParityDeals Python SDK provides a convenient way to interact with the ParityDeals REST APIs from your Python application. The SDK supports both synchronous and asynchronous operations.


## Installation

To install the ParityDeals SDK in your environment, run the following command:

```shell
pip install paritydeals-sdk
```

## Prerequisites

Before you can initialize the client and use the SDK methods, you need a Server API Key.

You can obtain this key from the ParityDeals application:

    1. Navigate to Settings.
    2. Go to the [Developers](https://app.paritydeals.com/settings/developers) section.
    3. Copy the Server API Key.

Once copied, add this key to your environment variables or directly in your code (though environment variables are recommended for security).


```python
# Example of setting it in your code (ensure you handle this securely)
ACCESS_TOKEN = "__YOUR_API_KEY__"
```

## Configuring the Client

The SDK supports both synchronous and asynchronous clients. The primary difference lies in how you create the client instance. Once created, both client types can invoke the same methods to communicate with the ParityDeals application.


#### How to Create a Synchronous Client

Use the synchronous client for traditional, blocking I/O operations.

```python
from paritydeals_sdk import ParityDeals

client = ParityDeals.create_sync_client(access_token=ACCESS_TOKEN)
```

#### How to Create an Asynchronous Client
Use the asynchronous client for non-blocking I/O operations, suitable for applications using `asyncio`.


```python
from paritydeals_sdk import ParityDeals

async_client = ParityDeals.create_async_client(access_token=ACCESS_TOKEN)
```



## Supported Functionalities

The SDK currently supports the following operations:

    1. Customers

    2. [Checkout](/backend-integration/python-sdk#checkout-client-checkout)

    3. [Entitlements](/backend-integration/python-sdk#entitlements-client-entitlements)

    4. [Reporting](/backend-integration/python-sdk#reporting-client-reporting)

    5. [Subscriptions](/backend-integration/python-sdk#subscriptions)


Further details on each method, including parameters and return values, should be added under each functionality.

---

## Checkout

The checkout module provides functionalities for creating and managing checkout sessions. You can access these operations via the checkout attribute on an initialized ParityDeals client instance.

`create_session(...)`
This operation creates a new checkout session for a customer, allowing them to proceed with a purchase or subscription.

**Synchronous**:

```python
response = client.checkout.create_session(
    paywallId="pw_123",
    ruleId="rule_abc",
    chargePeriod="MONTHLY",
    customerId="cust_789",
    features=[{'identifier':"seats", 'quantity': 5}],
    planIdentifier="plan_pro_monthly",
    successUrl="https://paritydeals.com/checkout/success"
)
print(f"Checkout Session URL: {response.checkoutUrl}")
```

**Asynchronous**:

```python
response = await async_client.checkout.create_session(
    paywallId="pw_123",
    ruleId="rule_abc",
    chargePeriod="MONTHLY",
    customerId="cust_789",
    features=[{'identifier':"seats", 'quantity': 5}],
    planIdentifier="plan_pro_monthly", # or offeringId="offer_xyz"
    successUrl="https://example.com/checkout/success"
)
print(f"Checkout Session URL: {response.checkoutUrl}")

```


<Accordion title="Response">

  ```json
   {
        "checkoutUrl": "https://checkout.stripe.com/c/pay/cs_test_b1sNi7D6u9iMCUFV1UZi9ZaiXKdOOmr3DCUW6XdCZIr5Id1F7#fid2cGd2ZndsdXsdjahsdkhsdhc%2FY2RpdmApJ3Zxd2x1YERmZmpwa3EnPydkZmZxWjRLZjV3X0BAckFBYGJKSEInKSdkdWxOYHwnPyd1blpxYHZxWjA0Tj1DSGdWRmwxYkdiMFxGQ29zf2BdTldOTGQzUlNqfWd9U1ZkanNHMlVnczxidEg0fFFqYVJNYzw8XEh2YVA8dkQ1bmA9NW5sS1c2PHE8dX89Q11Uf1E2NTVgY0M1Q0ZmYycpJ2N3amhWYHdzYHcnP3F3cGApJ2lkfGpwc",
        "checkoutSessionId": "cs_test_b1sNi7D6u9iMCUFV1UZi9ZwerfaiXKdOOmr3DCUW6XdCZIr5Id1F7G",
    }
  ```
</Accordion>

**Parameters**:


    * `paywallId` (str): Required. The id (uuid) of the paywall being used for this checkout.

    * `ruleId` (str): Required. The id (uuid) of the pricing rule being applied.

    * `chargePeriod` (ChargePeriod: Literal string): Required. The billing cycle for the subscription. Must be one of:

        * `"ONE_TIME"`

        * `"MONTHLY"`

        * `"YEARLY"`

        * `"WEEKLY"`

        * `"DAILY"`

        * `"THREE_MONTHS"`

        * `"SIX_MONTHS"`
    * `customerId` (str): Required. The ID of the customer initiating the checkout.

    * `featuresList` (List[Dict[str, Union[str, int]]]): **Required**. A list of dictionaries, where each dictionary represents a feature and its desired quantity. Each dictionary **must** have two keys:
        * `"identifier"` (str): The unique identifier for the feature.
        * `"quantity"` (int): The desired quantity for this feature.
            * Example: `[{"identifier": "seats", "quantity": 10}, {"identifier": "api-calls-tier1", "quantity": 5000}]`

    * `planIdentifier` (str): The identifier of the specific plan the customer is checking out with. planIdentifier is mandatory.

    * `offeringId` (Optional[str], default: None): The ID (uuid) of the offering the customer is checking out with.

    * `successUrl` (Optional[str], default: None): The URL to which the user will be redirected after a successful checkout. If not provided, and the checkout is initiated from a UI, it may default to redirecting back to that UI.

Constraint: You must provide planIdentifier and  chargePeriod.

**Returns**:

An instance of CreateCheckoutSessionResponse (Pydantic model), which includes:

    * `checkoutSessionId` (str): The unique ID for the created checkout session.

    * `checkoutUrl` (str): The URL that the customer should be redirected to in order to complete the payment and activate the subscription/purchase.

---

## Entitlements

The entitlements module allows you to check and retrieve customer entitlements for various features. These operations target a specific edge API endpoint (https://edge.api.paritydeals.com by default) and use the GET HTTP method with query parameters.


Checks if a specific customer has access to a particular feature. This method directly returns a boolean indicating access status.

**Synchronous**:

```python
has_feature_access = client.entitlements.has_access(
    customerId="cust_123",
    featureId="premium-reporting"
)
```

**Asynchronous**:

```python
has_feature_access = await async_client.entitlements.has_access(
    customerId="cust_456",
    featureId="advanced-analytics"
)
```

<Accordion title="Response">

  ```shell
   True
  ```
</Accordion>

**Parameters**:

    * `customerId` (str): Required. The unique identifier for the customer.

    * `featureId` (str): Required. The unique identifier for the feature whose access is being checked.

**Returns**:

    * `bool`: True if the customer has access to the specified feature (considering feature type, limits, etc.), False otherwise or if the feature is not found in their entitlements.


Retrieves the detailed entitlement information for a specific feature for a given customer.

**Synchronous**:

```python
entitlement_response = client.entitlements.get_entitlement(
    customerId="cust_123",
    featureId="premium-reporting"
)
```


**Asynchronous**:

```python
entitlement_response = await async_client.entitlements.get_entitlement(
    customerId="cust_456",
    featureId="advanced-analytics"
)
```

<Accordion title="Response">

  ```json
   {
        "customerId": "cust_456",
        "entitlements": [
            {
                "featureId": "advanced-analytics",
                "featureType": "METER",
                "hasAccess": true,
                "resetAt": "2025-05-22 08:27:45",
                "hardLimit": false,
                "usageLimit": 3,
                "currentUsage": 0,
                "remaining": 3
            }
        ]
   }
  ```
</Accordion>

**Parameters**:

    * `customerId` (str): Required. The unique identifier for the customer.

    * `featureId` (str): Required. The unique identifier for the feature whose access is being checked.

**Returns**:

An instance of CheckEntitlementsResponse (Pydantic model). When querying for a specific featureId, the entitlements list within this response is typically expected to contain a single EntitlementDetail object corresponding to the requested feature if found. The structure includes:

    * `customerId` (str): The customer's ID.

    * `entitlements` (List[EntitlementDetail]): A list containing the details for the requested feature. Each EntitlementDetail has fields like:

        * `featureId`: str

        * `hasAccess`: bool

        * `featureType`: Optional[str]

        * `resetAt`: Optional[str]

        * `hardLimit`: Optional[bool]

        * `usageLimit`: Optional[int]

        * `currentUsage`: Optional[int]

        * `remaining`: Optional[int]


Retrieves all entitlements for a given customer.

**Synchronous**:

```python
all_entitlements_response = client.entitlements.get_all_entitlements(
    customerId="cust_123"
)
```

**Asynchronous**:

```python
all_entitlements_response = await async_client.entitlements.get_all_entitlements(
    customerId="cust_456"
)
```

<Accordion title="Response">


  ```json
   {
        "customerId": "cust_456",
        "entitlements": [
            {
                "featureId": "advanced-analytics",
                "featureType": "METER",
                "hasAccess": true,
                "resetAt": "2025-05-22 08:27:45",
                "hardLimit": false,
                "usageLimit": 3,
                "currentUsage": 0,
                "remaining": 3
            }
        ]
    }
  ```
</Accordion>

**Parameters**:

    * `customerId` (str): Required. The unique identifier for the customer.

**Returns**:


    * `customerId` (str): The customer's ID.

    * `entitlements` (List[EntitlementDetail]): A list containing the details for the requested feature. Each EntitlementDetail has fields like:

        * `featureId`: str

        * `hasAccess`: bool

        * `featureType`: Optional[str]

        * `resetAt`: Optional[str]

        * `hardLimit`: Optional[bool]

        * `usageLimit`: Optional[int]

        * `currentUsage`: Optional[int]

        * `remaining`: Optional[int]

---

## Reporting

### Reporting calculated usages for customer

This endpoint is used for reporting the calculated feature usage from your application (client-level) to the ParityDeals application. It allows you to update the usage count for a specific feature associated with a customer.


**Synchronous**:

```python
# Assuming 'client' is your synchronous ParityDeals client
response = client.reporting.report_usage(
    value=150,
    customerId="customer_001",
    featureId="seats",
    behaviour="SET" # Or 'DELTA'
)
```

**Asynchronous**:

```python
# Assuming 'async_client' is your asynchronous ParityDeals client
response = await async_client.reporting.report_usage(
    value=75,
    customerId="customer_001",
    featureId="seats",
    behaviour="DELTA"
)
```

<Accordion title="Response">


  ```json
   {
        "value": 150,
        "customerId": "customer_001",
        "featureId": "seats",
        "behaviour": "SET",
        "orgId": "1",
        "eventName": "$usage.reported",
        "idempotencyKey": "597ee95063c744ed9bcc9b1cf5676a8a",
        "timestamp": "2025-05-22 08:27:45.430732"
    }
  ```
</Accordion>


**Parameters**:

    * `value` (int): Required. The usage value being reported.

    * `customerId` (str): Required. The unique identifier for the customer associated with this usage.

    * `featureId` (str): Required. The unique identifier for the feature for which usage is being reported.

    * `behaviour` parameter dictates how the usage is updated:

        * `SET`: This will replace the current usage value for the feature with the new `value` provided.

        * `DELTA`: This will increment the existing usage value for the feature by the amount specified in the `value` parameter


**Returns**:

An instance of ReportUsageResponse (Pydantic model), which includes:

    * `value` (int): The usage value that was recorded.

    * `customerId` (str): The customer ID associated with the usage.

    * `featureId` (str): The feature Identifier for which usage was recorded.

    * `behaviour` (str): The behaviour type ("SET" or "DELTA") that was processed.

    * `orgId` (str): The organization ID associated with this record, as determined by the server.

    * `eventName` (str): An internal event name generated by the server for this usage report (e.g., "$usage.reported").

    * `idempotencyKey` (str): A unique idempotency key generated by the server for this specific usage report instance.

    * `timestamp` (str): The server-generated UTC timestamp (string format) indicating when the usage report was processed.


### Reporting raw events for customer

Raw events are primarily used for metered billing scenarios, particularly when a customer is subscribed to a plan with usage-based billing (often referred to as "pay as you go"). Each event reported can contribute to the billable usage for that customer.

**Synchronous**:

```python
import uuid

# Assuming 'client' is your synchronous ParityDeals client
response = client.reporting.report_event(
    customerId="customer_002",
    eventName="api_invoked",
    idempotencyKey=uuid.uuid4().hex,
    timestamp="2025-05-22 07:53:55.747959",
    properties={"featureId": "api-usage", "value": 2}
)

```

**Asynchronous**:

```python
import uuid

# Assuming 'async_client' is your asynchronous ParityDeals client
response = await async_client.reporting.report_event(
    customerId="customer_002",
    eventName="api_invoked",
    idempotencyKey=uuid.uuid4().hex,
    timestamp="2025-05-22 07:53:55.747959",
    properties={"featureId": "api-usage", "value": 2}
)
```

<Accordion title="Response">


  ```json
   {
        "customerId": "customer_002",
        "eventName": "api_invoked",
        "idempotencyKey": "45f05c737a0b44d482c6042816d5645d",
        "timestamp": "2025-05-22 07:53:55.747959",
        "properties": {
            "featureId": "api-usage",
            "value": 2
        },
        "orgId": "1"
    }
  ```
</Accordion>


**Parameters**:

    * `customerId` (str): Required. The unique identifier for the customer who performed the event. (camelCase)

    * `eventName` (str): Required. The name of the event (e.g., "user_login", "item_purchased", "feature_activated"). (camelCase)

    * `idempotencyKey` (str): Required. A unique client-generated key to ensure that the event is processed at most once, even if the request is retried. A UUID is a good choice. (camelCase)

    * `timestamp` (str): Required. The UTC timestamp indicating when the event occurred. This must be a string formatted as "%Y-%m-%d %H:%M:%S.%f" (e.g., "2025-05-23 10:30:00.123456").

    * `properties` (Optional[Dict[str, Any]], default: None): A dictionary of additional custom properties associated with the event. Values can be strings, numbers, booleans.

**Returns**:

An instance of ReportEventResponse (Pydantic model), which includes:

    * `customerId` (str): The customer ID associated with the event.

    * `eventName` (str): The name of the event that was recorded.

    * `idempotencyKey` (str): The idempotency key that was used for the request.

    * `timestamp` (str): The timestamp (string format) that was recorded for the event.

    * `properties` (Optional[Dict[str, Any]]): The custom properties associated with the event, if provided and returned by the server.

    * `orgId` (str): The organization ID associated with this record, as determined by the server.

---

## Subscriptions

The subscriptions module allows you to manage customer subscriptions, including updates and cancellation. You can access these operations via the `subscriptions` attribute on an initialized ParityDeals client instance.


### Updates an existing subscription to a new plan


**Synchronous**:

```python
# Assuming 'client' is your synchronous ParityDeals client
try:
    response = client.subscriptions.update(
        subscriptionId="78058918-9746-4280-9b9b-1bd5115eec6e",
        planIdentifier="premium-plan",
        chargePeriod="MONTHLY", # e.g., "MONTHLY", "YEARLY"
        # Optional parameters below
        # offeringId="offer_abc",
        # paywallId="pw_def",
        # ruleId="rule_ghi",
        # features=[{'identifier': "seats", 'quantity': 10}]
    )
    print(response.message)
except Exception as e:
    print(f"Error updating subscription: {e}")
```


**Asynchronous**:

```python
# Assuming 'async_client' is your asynchronous ParityDeals client
try:
    response = await async_client.subscriptions.update(
        subscriptionId="78058918-9746-4280-9b9b-1bd5115eec6e",
        planIdentifier="new_plan_enterprise",
        chargePeriod="YEARLY",
        features=[{'identifier': "api-calls", 'quantity': 100000}]
    )
    print(response.message)
except Exception as e:
    print(f"Error updating subscription: {e}")
```

<Accordion title="Response">

  ```json
   {
      "message": "Subscription updated successfully."
   }
  ```
</Accordion>

**Parameters**:

* `subscriptionId` (str): Required. The unique identifier of the subscription to be updated.
* `planIdentifier` (str): Required. The identifier of the new plan.
* `chargePeriod` (str): Required. The new charging period for the subscription. Must be one of:
    * `"ONE_TIME"`
    * `"MONTHLY"`
    * `"YEARLY"`
    * `"WEEKLY"`
    * `"DAILY"`
    * `"THREE_MONTHS"`
    * `"SIX_MONTHS"`
* `offeringId` (Optional[str]): Optional. The ID of the new offering, if applicable.
* `paywallId` (Optional[str]): Optional. The ID of the new paywall, if applicable.
* `ruleId` (Optional[str]): Optional. The ID of the new pricing rule, if applicable.
* `features` (Optional[List[Dict[str, Any]]]): Optional. A list of dictionaries, where each dictionary represents a feature and its desired quantity to update for the subscription. Each dictionary **must** have two keys:
    * `"identifier"` (str): The unique identifier for the feature.
    * `"quantity"` (int): The desired quantity for this feature.
        * Example: `[{'identifier': 'seats', 'quantity': 10}, {'identifier': 'projects', 'quantity': 5}]`

**Returns**:

An instance of `UpdateSubscriptionResponse`, which includes:

* `message` (str): A confirmation message indicating the result of the update request.



### Cancel an active subscription for a customer.


**Synchronous**:

```python
# Assuming 'client' is your synchronous ParityDeals client
try:
    response = client.subscriptions.cancel(
        subscriptionId="78058918-9746-4280-9b9b-1bd5115eec6e",
        cancellationType="CURRENT_PERIOD_ENDS" # Or "IMMEDIATE", "SPECIFIC_DATE"
        # cancellationDate="2025-12-31" # Required if cancellationType is "SPECIFIC_DATE"
    )
    print(response.message)
except Exception as e:
    print(f"Error cancelling subscription: {e}")
```


**Asynchronous**:

```python
# Assuming 'async_client' is your asynchronous ParityDeals client
try:
    response = await async_client.subscriptions.cancel(
        subscriptionId="78058918-9746-4280-9b9b-1bd5115eec6e",
        cancellationType="IMMEDIATE"
    )
    print(response.message)
except Exception as e:
    print(f"Error cancelling subscription: {e}")
```

<Accordion title="Response">

  ```json
   {
      "message": "Subscription cancellation processed successfully."
   }
  ```
</Accordion>

**Parameters**:

* `subscriptionId` (str): Required. The unique identifier of the subscription to be cancelled.

* `cancellationType` (str): Required. The type of cancellation to perform. Must be one of:

    * `"IMMEDIATE"`: The subscription is cancelled immediately.
    * `"CURRENT_PERIOD_ENDS"`: The subscription will remain active until the end of the current billing period and then cancel.
    * `"SPECIFIC_DATE"`: The subscription will be cancelled on the specified `cancellationDate`.

* `cancellationDate` (Optional[str]): The specific date for cancellation if `cancellationType` is `"SPECIFIC_DATE"`. Must be in `YYYY-MM-DD` format. This parameter is **required** if `cancellationType` is `"SPECIFIC_DATE"`.

**Returns**:

An instance of `CancelSubscriptionResponse`, which includes:

* `message` (str): A confirmation message indicating the result of the cancellation request.

